&lt;
&gt;
&lt;?php
    /**
     * 3. PHP Avanzado
     */
    /**
     * 3.1. Integración de php con Bases de datos relacionales (Mysql)
     * *PHP proporciona una variedad de extensiones y funciones para trabajar con diferentes sistemas de gestión de bases de datos relacionales, como MySQL, PostgreSQL, Oracle, entre otros.
     */
    /**
     * 3.1.1. Bases de datos relacionales
     * SGBD: sistema de gestión de bases de datos
     * Bases de datos relacionales: informacion en tablas estructuradas (tiene filas y columnas) y se puede establecer relaciones entre ellas.
     *  estas se basan en el modelo relacional de Edgar Codd
     * *tabla es una entidad
     * *fila es una instancia de una entidad
     * *columna es una caracteristica de una entidad
     * *relaciones entre tablas mediante claves primarias (identifica a cada fila en una tabla) y claves foráneas (hace referencia a la clave primaria de otra tabla haciendo de esta forma una relacion entre las tablas)
     * *SQL: lenguaje de consulta estructurado - Structured Query Language
     * *Ejemplos de SGBD relacionales: MySQL, Oracle Database, Microsoft SQL Server y PostgreSQL.
     * *RDBMS: sistema de gestión de bases de datos relacionales
     */

    /**
     **Una tabla tiene un nombre y sus columnas tambien
     **Cada tabla tiene una columna para poder identificar de forma unica y que se suele llamar como "PRIMARY_KEY"
     **En caso de que la tabla tenga llaves foraneas "FOREIGN_KEY" esta referencia se pone en otra columna donde se pone la identificacion de llave primaria de otra tabla
     */

    /**
     * Ventajas RDBMS:
    **Menos redundancia
    **Prevención de inconsistencias: si se realiza el cambio en un lugar tambien ocurre en otros relacionados
    **Eficacia: un fragmento de informacion se almacena en menos ubicaciones
    **Integridad de los datos: a cada columna se le asigna ciertos tipo de dato que pueden almacenar
    **Confidencialidad: mas facil esta cuando hay centralizacion de la informacion
    */

    /**
     * Reglas para tablas de datos relacionales:
     **tablas con nombre distinto
    **tablas puede contener varias filas
    **cada tabla tiene un valor para identifica de forma unica las filas
    **cada columna en un tabla tiene un nombre unico 
    **las entradas (la informacion que almacenan) en las columnas son valores unicos
    **las entradas en las columnas son del mismo tipo
    **el orden de las filas y las columnas no es importante
    */

    /**
    * 3.1.2. Entidades y Atributos
    **Entidad: categorias de cosas
    *Ejemplo de entidad: usuarios y en esta entidad se guardan los usuarios que a su vez cada usuario tiene: nombre, apellido y otros
    **Tipos de entidades:
    *?Principal: Existe de forma independiente como instructor, cliente
    *?Caracteristica: Existe gracias a otra entidad (principal) como son tipos de instructores o tipos de clientes
    *?Interseccion: Existe gracias a dos o mas entidades como items segun tipos de instructores y o items segun tipos de clientes
    *
    **Entidades e instancias
    *?Las entidades contiene instancias (filas)
    *?Una instancia de entidad es una unica incidencia de una entidad (es decir que en un tabla no pueden haber dos filas iguales)
    *?Las entidades representan un juego de instancias que son de interes
    */

    /**
     * 3.1.3. Identificadores Únicos 
     * *Identificador único (clave unica o primaria): atributo o conjunto de atributos que permite identificar de manera exclusiva cada registro en una tabla, se usa para garantizar unicidad
     * *Características:
     * ?Unicidad: unico en la columna de una tabla
     * ?No nulidad: no toma valores nulos
     * ?Estabilidad: no cambian con el tiempo
     * ?Indexación: son usados para crear indices en la tabla
     * ?Referencialidad: servir para crear relaciones entre tablas
     * *Ejemplos:
     * ?Un campo de identificación autoincrementa
     * ?Una combinación de campos: al combinarse dos campos forma uno nuevo y unico
     * ?Un valor único generado externamente: como cedula, numero de seguro social y otros
     */

    /**
     * 3.1.4. Relaciones
     * Relacion: reglas que enlazan entidades
     * *Ejemplo: 
     * entidad1: empresa
     * entidad2: empleado
     * como se observa un empresa tiene varios empleados y con ello se establecen ciertas relaciones que puede ser de 1 a muchos y conjugndo varias posibilidades segun el contexto
     * *la linea de relacion puede ser solida (obligatoria) o discontinua (opcional)
     * *la linea termina en unica punta para una instancia o pata de gallo para una o mas instancias
     * *ejemplo de asignacion:
     * empresas contiene empleados
     * empleados se asigna a la empresas
     */

    /**
     * 3.1.5. Clave ajena (Foránea)
     * claves foraneas: son claves externas o ajenas para realizar cierta referencia de una tabla con otra
     * *La clave foránea en una tabla actúa como una referencia a una fila específica en otra tabla. 
     * *Caracteristicas:
     * ?Relación entre tablas: relaciones de uno a uno, uno a muchos o muchos a muchos, y se definen mediante la correspondencia entre la clave foránea y la clave primaria de la tabla referenciada
     * ?Integridad referencial: no se pueden agregar, modificar o eliminar registros en la tabla relacionada de una manera que rompa la relación establecida por la clave foránea
     * ?Restricciones de integridad: pueden tener restricciones asociadas, como la restricción de clave externa (foreign key constraint). Estas restricciones pueden especificar acciones como restringir o eliminar en cascada
     * ?Consultas y operaciones: permiten realizar consultas y operaciones que involucran múltiples tablas mediante la combinación de información relacionada
     * ?Mantenimiento de la consistencia: Si se actualiza la clave primaria en la tabla referenciada, las claves foráneas en otras tablas también se actualizarán automáticamente para mantener la integridad de los datos
     * *Ejemplo de dos tablas que usan la clave foranea:
     * !tabla empleados contiene: {empleado_id, nombre, apellido, empresa_id}, en esta el empleado_id es la clave primaria, empresa_id es donde se aloja esa llave foranea
     * !tabla empresas contiene: {empresa_id, nombre_empresa}, solo la llave primmaria: empresa_id
     * !como se observa se tiene una relacion de uno a muchos, donde uno es empresas y muchos es empleados
     * 
     * *Componentes de una relacion:
     * ?Nombre: etiqueta que aparece junto a la entidad asignada
     * ?Cardinalidad: es lo de uno a uno, uno a muchos o muchos a muchos
     * ?Opionalidad: opcion de que si debe existir una relacion o no. Opcional (0 registros coincidentes), Obligatorio (al menos un registro coincidente en cada entidad)
     */

     echo "Ejemplo de relacion de uno a muchos, de unica punta a pata de gallo&lt;br&gt;";
     echo "&lt;img src='relacion.PNG'&gt;&lt;br&gt;";

    /**
     * 3.1.6. Normalización de bases de datos
     *  Normalización de bases de datos: proceso de diseño que se utiliza para organizar y estructurar las tablas de una base de datos relacional de manera eficiente y libre de redundancias
     * *Objetivo principal de la normalizacion: eliminar la duplicación de datos y garantizar la integridad y consistencia de la información almacenada
     * *Formas normales se divivden en: 1NF, 2NF hasta 5NF, donde cada nivel tiene su respectiva especifidad
     * *1NF: 
     * ?Elimine los grupos repetidos de las tablas individuales.
     * ?Cree una tabla independiente para cada conjunto de datos relacionados.
     * ?Identifique cada conjunto de datos relacionados con una clave principal.
     * *2NF:
     * ?Cree tablas independientes para conjuntos de valores que se apliquen a varios registros.
     * ?Relacione estas tablas con una clave externa.
     * *3NF:
     * ?Elimine los campos que no dependan de la clave.
     */
    echo "Normalizacion: &lt;br&gt;";
    echo "&lt;a href='https://learn.microsoft.com/es-es/office/troubleshoot/access/database-normalization-description'&gt;Aqui hay un ejemplo de esta normalizacion&lt;/a&gt;&lt;br&gt;";
    echo "1.Tabla sin normalizar: &lt;br&gt;&lt;img src='no.PNG'&gt;&lt;br&gt;";
    /**
     * En este caso lo de clase 1, clase 2, clase 3 se pueden poner en una sola columna ya que son del mismo grupo las clases al final y se pone en N° clase
     */
    echo "2. 1NF: sin grupos repetidos: &lt;br&gt;&lt;img src='2.PNG'&gt;&lt;br&gt;";
    /**
     * Hay valores repetidos en la tabla anterior como Garcia y Diaz en Tutor
     */
    echo "3. 2NF: eliminar datos redundantes: &lt;br&gt;&lt;img src='3.PNG'&gt;&lt;br&gt;";
    /**
     * El Despacho-Tut depende del atributo Tutor, para ello se crea una tabla nueva 'Personal'
     * esto se hace ya que la clave primaria es de N°alumno por lo que Despacho-Tut al depende del tutor (ahora este es su llave primaria) se hace una tabla solo para ello
     */
    echo "4. 3NF: eliminar datos que no depende de la clave: &lt;br&gt;&lt;img src='4.PNG'&gt;&lt;br&gt;";

    /**
     * 3.2. Mysql
     * Mysql: sistema manejador de bases de datos de libre uso y distribución bajo licencia GPL,  disponible para varios sistemas operativos
     * *Popularidad: licencia libre, facilidad de uso  administracion
     * *LAMP: integra y combina: Linux, Apache, MySQL y PHP
     */

    /**
     * 3.2.1. Características MySQL
     * ?Velocidad: comparado a otras bases libres
     * ?Portabilidad: corre en windows, linux, unix
     * ?Facilidad de uso: facil de uso
     * ?Conectividad: pueden ser accedidas desde cualquier sitio de internet
     * ?Soporta lenguaje SQL: SQL
     * ?Seguridad: permite asignar permisos a nivel de usuario
     * ?Robustez: es muti-hilo y puede atender a varios usuarios de manera simultanea
     */

    /**
     * 3.2.2. Consola de MySQL
     * !!!!!!!!!! AUN FALTA LA PARTE DE VARIABLE DE ENTORNO PARA WINDOWS
     * 
     * *Ejecute el comando mysq –u [user] -p para iniciar sesión y luego la contraseña
    */

    /**
     * 3.2.3. Tipos de datos en MySQL
     */
    /**
     * 3.2.3.1 Tipos de datos numéricos
     */
    echo "Tipos de datos en MySQL&lt;br&gt;";
    echo "Tipos de datos enteros: &lt;br&gt;&lt;img src='datoINT.PNG'&gt;&lt;br&gt;";

    echo "Tipos de datos en coma flotante: &lt;br&gt;&lt;img src='datoFlo.PNG'&gt;&lt;br&gt;";

    /**
     * 3.2.3.2. Tipos de datos de carácter
     */
    echo "Tipos de datos de carácter: &lt;br&gt;&lt;img src='datoCar.PNG'&gt;&lt;br&gt;";

    /**
     * 3.2.3.3. Tipos de dato fecha
     */
    echo "Tipos de dato fecha: &lt;br&gt;&lt;img src='datoFecha.PNG'&gt;&lt;br&gt;";

    /**
     * 3.2.3.4. Modificadores o Constraints
     */
    echo "Modificadores o Constraints: &lt;br&gt;&lt;img src='const.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3. SQL Structured Query Language
     * SQL: lenguaje de programación utilizado para administrar y manipular bases de datos relacionales
     * ?permite a los usuarios crear, modificar y eliminar bases de datos, así como realizar consultas para recuperar información específica de una base de datos.
     * *Comandos:
     * !DDL (Data Definition Language): define y modifica estructura
     * ?incluye: CREATE (crea), ALTER (modifica), DROP (eliminar tablas, indices, vistas)
     * !DML (Data Manipulation Language): manipula datos almacenados
     * ?incluye; INSERT (agregar), UPDATE (actualizar), DELETE (eliminar)
     * !DQL (Data Query Language): realiza consultas y recuperar informacion
     * ?incluye: SELECT (para especificar criterios de busqueda y campos a recuperar)
     * !DCL (Data Control Language): controla privilegios de acceso
     * ?incluye: GRANT (otorga permisos), REVOKE (revoca permisos)
     */

    /**
     * 3.3.1. Que se puede hacer con SQL
     * *Crear y administrar bases de datos
     * *Insertar, actualizar y eliminar datos: INSERT, UPDATE y DELETE
     * *Consultar datos: SELECT
     * *Filtrar y ordenar datos: WHERE, ORDER BY
     * *Agregar funciones y cálculos: SUM, AVG, COUNT, MAX, MIN
     * *Crear vistas: tablas virtuales
     * *Establecer restricciones de integridad:
     */

    /**
     * 3.3.2. Comandos DDL
     * DDL (Data Definition Language) 
     * *permiten crear tablas, definir restricciones, modificar
     * *la estructura de las tablas existentes y eliminar objetos de la base de datos.
     */

    /**
     * 3.3.2.1 SHOW DATABASE: visualiza las bases de datosen el sevidor
     */
    echo "SHOW DATABASES: &lt;br&gt;&lt;img src='31.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3.2.2 CREATE DATABASE: crea una base de datos
     */
    echo "CREATE DATABASE: &lt;br&gt;&lt;img src='32.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3.2.2 DROP DATABASE: elimina una base de datos
     */
    echo "DROP DATABASE: &lt;br&gt;&lt;img src='33.PNG'&gt;&lt;br&gt;";
    
    /**
     * 3.3.2.4 USE: selecciona base de datos que se administrara
     */
    echo "USE: &lt;br&gt;&lt;img src='34.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3.2.5 CREATE TABLE: crea tabla en la base de datos que se esta administrando tras usar el USE
     */
    echo "CREATE TABLE: &lt;br&gt;&lt;img src='35.PNG'&gt;&lt;br&gt;";
    /** SHOW TABLES: muestra las tablas de una base de datos*/
    echo "SHOW TABLES: &lt;br&gt;&lt;img src='36.PNG'&gt;&lt;br&gt;";
    /** DESCRIBE nombre_tabla: visualiza la estructura de la tabla */
    echo "DESCRIBE nombre_tabla: &lt;br&gt;&lt;img src='37.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3.2.6 ALTER TABLE: modifica estructura de una tabla
     */

    /**
     * 3.3.2.7 Agregar columnas
     */
    echo "ALTER TABLE con ADD para agregar columnas: &lt;br&gt;&lt;img src='38.PNG'&gt;&lt;br&gt;";

    echo "Otro ejemplo para agregar columnas tipo date: &lt;br&gt;&lt;img src='39.PNG'&gt;&lt;br&gt;";

    /**
     * 3.3.2.8. Eliminar columnas
     * Sintaxis:
     * ALTER TABLE table_name
     * DROP COLUMN column_name;
     */

    /**
     * 3.3.2.9. Renombrar una columna
     * Sintaxis:
     * ALTER TABLE table_name
     * RENAME COLUMN old_name to new_name;
     */

    /**
     * 3.3.2.10. Modificar el tipo de dato
     * Sintaxis:
     * ALTER TABLE table_name
     * MODIFY COLUMN column_name datatype;
     */

    /**
     * 3.3.2.11 CONSTRAINTS
     * *son restricciones que se aplican a las columnas de una tabla para mantener la integridad de los datos y se cumplean condiciones
     * !Tipos de constraint más comunes en MySQL
     * *PRIMARY KEY: Es una restricción que se utiliza para identificar de manera única cada fila en una tabla.
     * ?FOREIGN KEY: Es una restricción que establece una relación entre dos tablas, utilizando una
     * ?columna o un conjunto de columnas en una tabla (la foreign key) que hace referencia a la 
     * ?primary key de otra tabla (la tabla referenciada)
     * *UNIQUE: Es una restricción que garantiza que los valores en una columna o conjunto de columnas sean únicos en la tabla.
     * ?NOT NULL: Es una restricción que indica que una columna no puede contener valores nulos. 
     * *CHECK:  Es una restricción que permite definir condiciones específicas para los valores de una columna, por ejemplo: Solo se permite 
     * *insertar o actualizar registros que cumplan con la condición definida. 
     */


    /**
     * 3.3.2.12. PRIMARY KEY
     */
    echo "Tabla sin llave primaria: &lt;br&gt;&lt;img src='prim.PNG'&gt;&lt;br&gt;";
    /**
     * Al existir la tabla se ejecutaria esto para resolver este problema:
     */
    echo "Añade llave primaria a la tabla: &lt;br&gt;&lt;img src='prim1.PNG'&gt;&lt;br&gt;";

    /**
     * !AUN FALTA
     */


    /**
     * 3.3.3. Comandos DML
     * *manipulación de los registros en las bases de datos
     */ 

    /**
     * 3.3.3.1. INSERT INTO
     * INSERT INTO table_name (col1, col2)
     * VALUES (val1,val2); //para insertar valores a una tabla
     * 
     * *varios valores en una columna
     * INSERT INTO table_name (col1) VALUES (val1),(val2),(val3);
     * 
     * Nota. Cuando la tabla cuenta con una columna autoincremental no es necesario pasar como
     * argumento el nombre de la columna ni el valor
     */

    /**
     * 3.3.3.2. Update
     * para modificar los datos existentes en una tabla
     * UPDATE table_name
     *SET col1='val1', col2='val2'
     *WHERE id=1; //para modificar un valor
     */

    /**
     * 3.3.3.3 DELETE
     * eliminar registros existentes de una tabla
     * DELETE FROM table_name WHERE id=5; //para eliminar un dato en una tabla
     */

    /**
     * 3.3.4. Comandos DQL
     * recuperar y consultar datos de una base de datos
     */

    /**
     * 3.3.4.1 SELECT
     * SELECT col1, col2 FROM table_name; //consultar dos columnas de una tabla
     */

    /**
     * 3.3.4.2. WHERE
     * SELECT col1, col2
     *FROM table_name
     *WHERE id=2; //consultar dos columnas  de una tabla segun id=1
     */

    /**
     * !!!!!FALTA
     */

    /**
     * 3.4 Introduccion a PDO
     * PDO: PHP Data Objects:  interfaz de abstracción de bases de datos en PHP
     *  Proporciona un conjunto de clases y métodos para preparar y ejecutar consultas SQL de una 
     *  manera segura y eficiente.
     * *proporciona una forma unificada de trabajar con diferentes tipos de bases de datos
     * *principal ventaja: capacidad para trabajar con parámetros vinculados y consultas preparadas:  puede ayudar a proteger tu aplicación contra ataques de inyección de SQL.
     */

    /**
     * El primer argumento de la clase PDO es el DSN, DataSourceName, en el cual se han de especificar el tipo de base de datos. 
     */
    try {
        $dsn="mysql:host=localhost;dbname=$dbname";
        $dbh=new PDO($dsn, $user, $password);
    } catch (PDOException $e) {
        echo $e-&gt;getMessage();
    }
    /**
     * 3.4.1. Excepciones y opciones con PDO
     * PDO maneja los errores en forma de excepciones, por lo que la conexión siempre ha de ir encerrada en un bloque try/catch.
     * *Se puede (y se debe) especificar el modo de error estableciendo el atributo error mode:
     */
    /**
     * PDO::ERRMODE_SILENT
     * Es el modo de error por defecto
     * * Si se deja así con este habrá que comprobar los errores de forma parecida a como se hace con mysqli.
     * */
    $dbh-&gt;setAttribute(PDO::ATTRR_ERRMODE, PDO::ERRMODE_SILENT); 

    /**
     * PDO::errorCode: https://www.php.net/manual/es/pdo.errorcode.php
     * PDO::errorInfo: https://www.php.net/manual/es/pdo.errorinfo.php
     * PDOStatement::errorCode: https://www.php.net/manual/es/pdostatement.errorcode.php
     * PDOStatement::errorInfo: https://www.php.net/manual/es/pdostatement.errorinfo.php
     */
    $dbh-&gt;setAttribute(PDO::ATTRR_ERRMODE, PDO::ERRMODE_WARNIND);
    $dbh-&gt;setAttribute(PDO::ATTRR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    /**
     * PDO::ERRMODE_SILENT. Es el modo de error por defecto. Si se deja así habrá que comprobar
los errores de forma parecida a como se hace con mysqli. Se tendrían que emplear
PDO::errorCode() y PDO::errorInfo() o su versión en PDOStatement PDOStatement::errorCode()
y PDOStatement::errorInfo().

     */

     /**
      * 
       PDO::ERRMODE_WARNING. Además de establecer el código de error, PDO emitirá un mensaje
E_WARNING. Modo empleado para depurar o hacer pruebas para ver errores sin interrumpir el
flujo de la aplicación
      */

      /**
       *  PDO::ERRMODE_EXCEPTION. Además de establecer el código de error, PDO lanzará una
excepción PDOException y establecerá sus propiedades para luego poder reflejar el error y su
información. Este modo se emplea en la mayoría de situaciones, ya que permite manejar los
errores y a la vez esconder datos que podrían ayudar a alguien a atacar tu aplicación.
       */

/**
 * 3.6 Api Rest
Un API (Application Programming Interface, por sus siglas en inglés) es un conjunto de reglas y
protocolos que permite la comunicación entre distintos sistemas informáticos. En términos simples,
es una interfaz que define cómo los diferentes componentes de software deben interactuar entre sí.
Un API proporciona una forma estandarizada y estructurada para que las aplicaciones y servicios se
comuniquen y compartan datos y funcionalidades. A través de un API, una aplicación puede solicitar
información o realizar acciones en otra aplicación o servicio, sin necesidad de conocer los detalles
internos de cómo se implementa dicha funcionalidad.
Existen diferentes tipos de API, como las API web, que permiten la comunicación entre aplicaciones a
través de Internet utilizando protocolos como HTTP. También existen las API de sistema operativo,
que proporcionan acceso a las funciones y recursos del sistema operativo subyacente, y las API de
biblioteca, que ofrecen funciones y servicios específicos a los desarrolladores.
Las API han sido fundamentales en el desarrollo de aplicaciones modernas, ya que permiten la
integración de diferentes sistemas, el intercambio de datos y la creación de servicios y aplicaciones
más complejas a través de la reutilización de componentes existentes. También son ampliamente
utilizadas en el desarrollo de interfaces de programación para servicios web (API web) y aplicaciones
móviles, permitiendo la interacción con plataformas populares y servicios en la nube.
 */

    /**
     * 
     * 3.6.2. Códigos de estado en Response HTTP
3.6.2.1. Respuestas informativas
100 Continue
Esta respuesta provisional indica que todo hasta ahora está bien y que el cliente debe continuar con
la solicitud o ignorarla si ya está terminada.
101 Switching Protocol
Este código se envía en respuesta a un encabezado de solicitud Upgrade (en-US) por el cliente e
indica que el servidor acepta el cambio de protocolo propuesto por el agente de usuario.
102 Processing (en-US) (WebDAV (en-US))
Este código indica que el servidor ha recibido la solicitud y aún se encuentra procesandola, por lo
que no hay respuesta disponible.
103 Early Hints (en-US)
Este código de estado está pensado principalmente para ser usado con el encabezado Link,
permitiendo que el agente de usuario empiece a pre-cargar (en-US) recursos mientras el servidor
prepara una respuesta.
3.6.2.2 Respuestas satisfactorias
 GET: El recurso se ha obtenido y se transmite en el cuerpo del mensaje.
 HEAD: Los encabezados de entidad están en el cuerpo del mensaje.
 PUT o POST: El recurso que describe el resultado de la acción se transmite en el
cuerpo del mensaje.
 TRACE: El cuerpo del mensaje contiene el mensaje de solicitud recibido por el
servidor.
200 OK
La solicitud ha tenido éxito. El significado de un éxito varía dependiendo del método HTTP:
201 Created
La solicitud ha tenido éxito y se ha creado un nuevo recurso como resultado de ello. Ésta es
típicamente la respuesta enviada después de una petición PUT.
202 Accepted
La solicitud se ha recibido, pero aún no se ha actuado. Es una petición "sin compromiso", lo que
significa que no hay manera en HTTP que permite enviar una respuesta asíncrona que indique el
resultado del procesamiento de la solicitud. Está pensado para los casos en que otro proceso o
servidor maneja la solicitud, o para el procesamiento por lotes.
203 Non-Authoritative Information
La petición se ha completado con éxito, pero su contenido no se ha obtenido de la fuente
originalmente solicitada, sino que se recoge de una copia local o de un tercero. Excepto esta condición,
se debe preferir una respuesta de 200 OK en lugar de esta respuesta.
204 No Content (en-US)
La petición se ha completado con éxito, pero su respuesta no tiene ningún contenido, aunque los
encabezados pueden ser útiles. El agente de usuario puede actualizar sus encabezados en caché para
este recurso con los nuevos valores.
205 Reset Content (en-US)
La petición se ha completado con éxito, pero su respuesta no tiene contenidos y además, el agente
de usuario tiene que inicializar la página desde la que se realizó la petición, este código es útil por
ejemplo para páginas con formularios cuyo contenido debe borrarse después de que el usuario lo
envíe.
206 Partial Content
La petición servirá parcialmente el contenido solicitado. Esta característica es utilizada por
herramientas de descarga como wget para continuar la transferencia de descargas anteriormente
interrumpidas, o para dividir una descarga y procesar las partes simultáneamente.
207 Multi-Status (en-US) (WebDAV (en-US))
Una respuesta Multi-Estado transmite información sobre varios recursos en situaciones en las que
varios códigos de estado podrían ser apropiados. El cuerpo de la petición es un mensaje XML.
208 Multi-Status (en-US) (WebDAV (en-US))
El listado de elementos DAV ya se notificó previamente, por lo que no se van a volver a listar.
226 IM Used (en-US) (HTTP Delta encoding)
El servidor ha cumplido una petición GET para el recurso y la respuesta es una representación del
resultado de una o más manipulaciones de instancia aplicadas a la instancia actual.
3.6.2.3. Redirecciones
300 Multiple Choice (en-US)
Esta solicitud tiene más de una posible respuesta. User-Agent o el usuario debe escoger uno de ellos.
No hay forma estandarizada de seleccionar una de las respuestas.
301 Moved Permanently (en-US)
Este código de respuesta significa que la URI del recurso solicitado ha sido cambiado. Probablemente
una nueva URI sea devuelta en la respuesta.
302 Found
Este código de respuesta significa que el recurso de la URI solicitada ha sido cambiado
temporalmente. Nuevos cambios en la URI serán agregados en el futuro. Por lo tanto, la misma URI
debe ser usada por el cliente en futuras solicitudes.
303 See Other (en-US)
El servidor envía esta respuesta para dirigir al cliente a un nuevo recurso solicitado a otra dirección
usando una petición GET.
304 Not Modified
Esta es usada para propósitos de "caché". Le indica al cliente que la respuesta no ha sido modificada.
Entonces, el cliente puede continuar usando la misma versión almacenada en su caché.
305 Use Proxy Obsoleto
Fue definida en una versión previa de la especificación del protocolo HTTP para indicar que una
respuesta solicitada debe ser accedida desde un proxy. Ha quedado obsoleta debido a
preocupaciones de seguridad correspondientes a la configuración de un proxy.
306 unused
Este código de respuesta ya no es usado más. Actualmente se encuentra reservado. Fue usado en
previas versiones de la especificación HTTP1.1.
307 Temporary Redirect (en-US)
El servidor envía esta respuesta para dirigir al cliente a obtener el recurso solicitado a otra URI con el
mismo método que se usó la petición anterior. Tiene la misma semántica que el código de respuesta
HTTP 302 Found, con la excepción de que el agente usuario no debe cambiar el método HTTP usado:
si un POST fue usado en la primera petición, otro POST debe ser usado en la segunda petición.
308 Permanent Redirect (en-US)
Significa que el recurso ahora se encuentra permanentemente en otra URI, especificada por la
respuesta de encabezado HTTP Location:. Tiene la misma semántica que el código de respuesta
HTTP 301 Moved Permanently, con la excepción de que el agente usuario no debe cambiar el
método HTTP usado: si un POST fue usado en la primera petición, otro POST debe ser usado en la
segunda petición.
3.6.2.4. Errores de cliente
400 Bad Request
Esta respuesta significa que el servidor no pudo interpretar la solicitud dada una sintaxis inválida.
401 Unauthorized
Es necesario autenticar para obtener la respuesta solicitada. Esta es similar a 403, pero en este caso,
la autenticación es posible.
402 Payment Required
Este código de respuesta está reservado para futuros usos. El objetivo inicial de crear este código fue
para ser utilizado en sistemas digitales de pagos. Sin embargo, no está siendo usado actualmente.
403 Forbidden
El cliente no posee los permisos necesarios para cierto contenido, por lo que el servidor está
rechazando otorgar una respuesta apropiada.
404 Not Found
El servidor no pudo encontrar el contenido solicitado. Este código de respuesta es uno de los más
famosos dada su alta ocurrencia en la web.
405 Method Not Allowed (en-US)
El método solicitado es conocido por el servidor pero ha sido deshabilitado y no puede ser utilizado.
Los dos métodos obligatorios, GET y HEAD, nunca deben ser deshabilitados y no deberían retornar
este código de error.
406 Not Acceptable (en-US)
Esta respuesta es enviada cuando el servidor, después de aplicar una negociación de contenido
servidor-impulsado (en-US), no encuentra ningún contenido seguido por la criteria dada por el
usuario.
407 Proxy Authentication Required (en-US)
Esto es similar al código 401, pero la autenticación debe estar hecha a partir de un proxy.
408 Request Timeout
Esta respuesta es enviada en una conexión inactiva en algunos servidores, incluso sin alguna petición
previa por el cliente. Significa que el servidor quiere desconectar esta conexión sin usar. Esta
respuesta es muy usada desde algunos navegadores, como Chrome, Firefox 27+, o IE9, usa
mecanismos de pre-conexión HTTP para acelerar la navegación. También hay que tener en cuenta
que algunos servidores simplemente desconectan la conexión sin enviar este mensaje.
409 Conflict (en-US)
Esta respuesta puede ser enviada cuando una petición tiene conflicto con el estado actual del
servidor.
410 Gone (en-US)
Esta respuesta puede ser enviada cuando el contenido solicitado ha sido borrado del servidor.
411 Length Required (en-US)
El servidor rechaza la petición porque el campo de encabezado Content-Length no está definido y el
servidor lo requiere.
412 Precondition Failed (en-US)
El cliente ha indicado pre-condiciones en sus encabezados la cual el servidor no cumple.
413 Payload Too Large
La entidad de petición es más larga que los límites definidos por el servidor; el servidor puede cerrar
la conexión o retornar un campo de encabezado Retry-After.
414 URI Too Long (en-US)
La URI solicitada por el cliente es más larga de lo que el servidor está dispuesto a interpretar.
415 Unsupported Media Type (en-US)
El formato multimedia de los datos solicitados no está soportado por el servidor, por lo cual el
servidor rechaza la solicitud.
416 Requested Range Not Satisfiable (en-US)
El rango especificado por el campo de encabezado Range en la solicitud no cumple; es posible que el
rango está fuera del tamaño de los datos objetivo del URI.
417 Expectation Failed (en-US)
Significa que la expectativa indicada por el campo de encabezado Expect solicitada no puede ser
cumplida por el servidor.
418 I'm a teapot
El servidor se rehúsa a intentar hacer café con una tetera.
421 Misdirected Request (en-US)
La petición fue dirigida a un servidor que no es capaz de producir una respuesta. Esto puede ser
enviado por un servidor que no está configurado para producir respuestas por la combinación del
esquema y la autoridad que están incluidos en la URI solicitada
422 Unprocessable Entity (en-US) (WebDAV (en-US))
La petición estaba bien formada pero no se pudo seguir debido a errores de semántica.
423 Locked (en-US) (WebDAV (en-US))
El recurso que está siendo accedido está bloqueado.
424 Failed Dependency (en-US) (WebDAV (en-US))
La petición falló debido a una falla de una petición previa.
426 Upgrade Required (en-US)
El servidor se rehúsa a aplicar la solicitud usando el protocolo actual, pero puede estar dispuesto a
hacerlo después que el cliente se actualice a un protocolo diferente. El servidor envía un encabezado
Upgrade en una respuesta para indicar los protocolos requeridos.
428 Precondition Required (en-US)
El servidor origen requiere que la solicitud sea condicional. Tiene la intención de prevenir problemas
de 'actualización perdida', donde un cliente OBTIENE un estado del recurso, lo modifica, y lo PONE
devuelta al servidor, cuando mientras un tercero ha modificado el estado del servidor, llevando a un
conflicto.
429 Too Many Requests (en-US)
El usuario ha enviado demasiadas solicitudes en un periodo de tiempo dado.
431 Request Header Fields Too Large (en-US)
El servidor no está dispuesto a procesar la solicitud porque los campos de encabezado son
demasiado largos. La solicitud PUEDE volver a subirse después de reducir el tamaño de los campos
de encabezado solicitados.
451 Unavailable For Legal Reasons (en-US)
El usuario solicita un recurso ilegal, como alguna página web censurada por algún gobierno.
3.6.2.5. Errores de servidor
500 Internal Server Error
El servidor ha encontrado una situación que no sabe cómo manejarla.
501 Not Implemented (en-US)
El método solicitado no está soportado por el servidor y no puede ser manejado. Los únicos métodos
que los servidores requieren soporte (y por lo tanto no deben retornar este código) son GET y HEAD.
502 Bad Gateway
Esta respuesta de error significa que el servidor, mientras trabaja como una puerta de enlace para
obtener una respuesta necesaria para manejar la petición, obtuvo una respuesta inválida.
503 Service Unavailable
El servidor no está listo para manejar la petición. Causas comunes puede ser que el servidor está caído
por mantenimiento o está sobrecargado. Hay que tomar en cuenta que, junto con esta respuesta, una
página usuario-amigable explicando el problema debe ser enviada. Estas respuestas deben ser usadas
para condiciones temporales y el encabezado HTTP Retry-After: debería, si es posible, contener el
tiempo estimado antes de la recuperación del servicio. El webmaster debe también cuidar los
encabezados relacionados al caché que son enviados junto a esta respuesta, ya que estas respuestas
de condición temporal deben usualmente no estar en el caché.
504 Gateway Timeout
Esta respuesta de error es dada cuando el servidor está actuando como una puerta de enlace y no
puede obtener una respuesta a tiempo.
505 HTTP Version Not Supported
La versión de HTTP usada en la petición no está soportada por el servidor.
506 Variant Also Negotiates (en-US)
El servidor tiene un error de configuración interna: negociación de contenido transparente para la
petición resulta en una referencia circular.
507 Insufficient Storage (en-US)
El servidor tiene un error de configuración interna: la variable de recurso escogida está configurada
para acoplar la negociación de contenido transparente misma, y no es por lo tanto un punto final
adecuado para el proceso de negociación.
508 Loop Detected (en-US) (WebDAV (en-US))
El servidor detectó un ciclo infinito mientras procesaba la solicitud.
510 Not Extended (en-US)
Extensiones adicionales para la solicitud son requeridas para que el servidor las cumpla.
511 Network Authentication Required (en-US)
El código de estado 511 indica que el cliente necesita autenticar para obtener acceso a la red.
     */

/**
 * 
 * 3.6.3. Tipos de autenticación
En API REST, existen varios métodos de autenticación que se utilizan para garantizar la seguridad y
proteger los recursos. Aquí tienes algunos ejemplos comunes de tipos de autenticación en API REST:
 Autenticación basada en token (Token-Based Authentication): En este enfoque, el cliente
envía un token de acceso con cada solicitud al servidor. El token es emitido por el servidor
después de que el cliente proporciona sus credenciales de autenticación (como nombre de
usuario y contraseña) de manera segura. El servidor verifica la validez del token antes de
procesar la solicitud. Ejemplos de implementaciones populares de este tipo de autenticación
son JSON Web Tokens (JWT) y OAuth 2.0.
 Autenticación básica (Basic Authentication): En este método, el cliente envía las credenciales
(nombre de usuario y contraseña) codificadas en Base64 en el encabezado de la solicitud.
Aunque es fácil de implementar, la autenticación básica no cifra las credenciales y, por lo
tanto, no se considera segura para entornos no HTTPS.
 Autenticación mediante API key (API Key Authentication): En este enfoque, el cliente envía
una clave de API junto con la solicitud al servidor. La clave de API es un identificador único y
secreto que se emite al cliente para autenticarse en cada solicitud. El servidor verifica la
validez de la clave de API antes de procesar la solicitud.
 Autenticación mediante OAuth: OAuth es un protocolo de autorización que permite a una
aplicación solicitar acceso a los recursos protegidos en nombre de un usuario. El cliente
obtiene un token de acceso válido después de que el usuario autoriza la aplicación. Este token
se utiliza posteriormente para autenticar las solicitudes al servidor.
3.6.4. Implementando ApiRest (Slim)
Slim Framework es un framework de desarrollo de aplicaciones web minimalista y ligero para PHP.
Está diseñado para ser simple y rápido, permitiendo a los desarrolladores crear aplicaciones web
poderosas y eficientes con una curva de aprendizaje mínima.
Slim Framework se destaca por su enfoque minimalista y su capacidad para crear API y aplicaciones
web rápidas y sencillas. Proporciona una base sólida para construir aplicaciones, sin agregar una
cantidad abrumadora de características y complejidad innecesaria.
Algunas características clave de Slim Framework incluyen:
 Enrutamiento: Permite definir rutas para responder a diferentes solicitudes HTTP
(GET, POST, PUT, DELETE, etc.) y asociarlas con controladores y acciones específicas.
 Manejo de solicitudes y respuestas: Proporciona una interfaz simple y flexible para
manejar y manipular solicitudes HTTP entrantes y generar respuestas HTTP salientes.
 Contenedores de dependencias: Incorpora un contenedor de dependencias para
gestionar la creación y resolución de objetos y sus dependencias.
 Middleware: Permite agregar capas adicionales de funcionalidad en el proceso de
solicitud y respuesta, como la autenticación, el registro de solicitudes, el
almacenamiento en caché, entre otros.
 Plantillas: Ofrece soporte para diferentes motores de plantillas, lo que facilita la
creación de vistas y la separación de la lógica de presentación del resto de la
aplicación.
Slim Framework es conocido por su flexibilidad y su énfasis en la simplicidad. Es una opción popular
para aquellos que buscan un marco de trabajo ágil y fácil de usar para desarrollar aplicaciones web y
API con PHP.
Para crear un proyecto usando ese framework siga los siguientes pasos:
1. cree una carpeta en la cual desea almacenar el nuevo proyecto. se recomienda que esta
carpeta se encuentre ubicada en la carpeta principal del servidor web.
2. Haciendo uso del gestor de extensiones composer ingrese el siguiente comando desde la
carpeta del proyecto: composer require slim/slim:"4.*"
3. Configure el sistema PSR 7 y el Server request. Para esto ejecute el comando composer
require slim/psr7
4. Cree el archivo index.php en la raíz del proyecto
 */
?&gt;